# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyProject Git Commad Group
#   Git Related Functions for MyProject

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

mycmd:command_group.register_version "0.1"
mycmd:command_group.register_short_description "MyProject Git Command Group Library"
mycmd:command_group.register_help_text "The MyProject Project Task Runner Git Library"

[[ -n "${_MYCMD_SOURCING_FOR_HELP:-}" ]] && return

[[ -n "${_GIT_LIB:-}" ]] && return
readonly _GIT_LIB=1

mycmd.add_to_init_bin_batch git

function git._execute_git() {
    mycmd.bin_execute git "${@}"
}

function git._execute_git_working_dir() {
    local working_dir="${1}"
    shift

    mycmd.bin_execute git -C "${working_dir}" "${@}"
}

function git.is_working_tree_dirty() {
    local status
    if ! status="$(git._execute_git status --porcelain 2>&1)"; then
        return 1
    fi

    [[ -n "${status-}" ]]
}

function git.has_unstaged_changes_in_paths() {
    if (($# > 0)); then
        set -- --quiet --exit-code -- "${@}"
    else
        set -- --quiet --exit-code
    fi

    # This returns non-zero if there are changes, and we want the opposite
    if ! git._execute_git diff "${@}" 2>/dev/null; then
        return 0
    else
        return 1
    fi
}

function git.commit_changes_in_paths_with_message() {
    local -r message="${1}"
    shift

    if (($# == 0)); then
        myproject.output_only_if_not_quiet "Adding all changes across the working tree."
        set -- --all
    fi

    if ! git._execute_git add "${@}"; then
        mycmd.error_output "Error adding changes to the index."
        return 1
    fi

    if ! git._execute_git commit --message="${message}" "${@}"; then
        mycmd.error_output "Error committing changes."
        return 1
    fi

    return 0
}

function git.list_tags() {
    local -n dest_array_ref="${1}"
    shift

    if (($# > 0)); then
        local pattern="${*}"

        # shellcheck disable=SC2312
        readarray -t dest_array_ref < <(git._execute_git tag -l "${pattern}" --sort=-v:refname)
    else
        # shellcheck disable=SC2312
        readarray -t dest_array_ref < <(git._execute_git tag -l --sort=-v:refname)
    fi

    mycmd.trace "Retrieved ${#dest_array_ref[@]} tag names from repository."
}

function git.create_lightweight_tag() {
    if (($# < 1)); then
        mycmd.error_output "Missing tag name to create."
        return 1
    fi

    local -r tag_name="${1}"
    local commit

    if (($# == 1)); then
        commit="HEAD"
    else
        commit="${2}"
    fi
    readonly commit

    if ! git._execute_git tag "${tag_name}" "${commit}"; then
        return 1
    fi

    project.verbose_output "Created tag '${tag_name}' at commit '${commit}'."
}

function git.create_annotated_tag() {
    local -r tag_name="${1}"
    local -r commit="${2}"
    local -n message_parts_array_ref="${3}"

    local -a git_arguments=("tag" "-a")

    local message_line
    for message_line in "${message_parts_array_ref[@]}"; do
        git_arguments+=("-m" "${message_line}")
    done

    git_arguments+=("${commit}" "${tag_name}")

    if ! git._execute_git "${git_arguments[@]}"; then
        return 1
    fi

    project.verbose_output "Created annotated tag '${tag_name}' at commit '${commit}'."
}

function git.push_changes_with_annotated_tags() {
    project.output_only_if_not_quiet "Pushing to remote with tags."

    if project.is_verbose_enabled; then
        git._execute_git push --follow-tags
    else
        git._execute_git push --quiet --follow-tags
    fi
}

mycmd.add_to_init_bin_batch grep
function git.commit_is_tagged_matching_pattern() {
    local -r commit="${1}"
    local -r pattern="${2}"

    local canonicalized_commit
    if ! canonicalized_commit="$(git._execute_git rev-parse "${commit}")"; then
        mycmd.error_output "Cannot find commit '${commit}'."
        return 1
    fi

    git._execute_git \
        for-each-ref \
        refs/tags \
        --format='%(refname:short)' \
        --points-at="${canonicalized_commit}" \
        | mycmd.bin_execute grep -q "${pattern}"
}

function git.current_tag_for_worktree() {
    local -r commit="${1}"
    local -r pattern="${2}"

    local canonicalized_commit
    if ! canonicalized_commit="$(git._execute_git rev-parse "${commit}")"; then
        mycmd.error_output "Cannot find commit '${commit}'."
        return 1
    fi

    git._execute_git \
        for-each-ref \
        refs/tags \
        --format='%(refname:short)' \
        --points-at="${canonicalized_commit}"
}

function git.add_worktree_at_detached_commit() {
    local -r worktree_dir="${1}"
    local -r commitish="${2}"

    if project.is_verbose_enabled; then
        git._execute_git worktree add --detach "${worktree_dir}" "${commitish}"
    else
        git._execute_git worktree add --quiet --detach "${worktree_dir}" "${commitish}"
    fi
}

function git.update_worktree_to_commitish() {
    local -r worktree_dir="${1}"
    local -r commitish="${2}"

    if project.is_verbose_enabled; then
        git._execute_git_working_dir "${worktree_dir}" checkout --detach "${commitish}"
    else
        git._execute_git_working_dir "${worktree_dir}" checkout --quiet --detach "${commitish}"
    fi
}

function git.fetch_tags() {
    if project.is_verbose_enabled; then
        git._execute_git fetch --tags
    else
        git._execute_git fetch --tags --quiet
    fi
}

function git.create_github_release() {
    if ! mycmd.init_bin_no_exit gh; then
        mycmd.error_output "Required tool 'gh' not found."
        return 1
    fi

    local -r release_name="${1}"
    local -r release_tag="v${release_name}"
    local -r release_tarball="${2}"
    local -r release_notes="${3}"

    if [[ ! -e "${release_tarball}" ]]; then
        mycmd.error_output "Missing release tarball '${release_tarball}'."
        return 1
    fi

    if [[ ! -e "${release_notes}" ]]; then
        mycmd.error_output "Missing release notes file '${release_notes}'."
        return 1
    fi

    mycmd.bin_execute gh release create "${release_tag}" -F "${release_notes}" "${release_tarball}"
}

mycmd.trace "The MyProject Git Command Group library has been sourced."
