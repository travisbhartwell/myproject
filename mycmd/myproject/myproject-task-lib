# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyCmd Project Task Command Group Support Library
#   Support for Task Definition Data Structures and Related Functions for MyProject

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_MYPROJECT_TASK_LIB:-}" ]] && return
readonly _MYPROJECT_TASK_LIB=1

declare -Agx _MYPROJECT_TASKS

readonly _TASK_FULLY_QUALIFIED_NAME_FIELD='task-fully-qualified-name'
readonly _TASK_NAME_FIELD='task-name'
readonly _TASK_NAMESPACED_PARTS_STRING_FIELD='task-namespaced-parts-string'
readonly _TASK_FUNCTION_FIELD='task-function'

function project:task_registry._reset_registry() {
    mycmd.trace "Resetting the MyProject Task Registry."
    _MYPROJECT_TASKS=()
}

project:task_registry._reset_registry

function project:task_registry.new_task() {
    local -r fully_qualified_task_name="${1}"
    local -r task_function_name="${2}"

    mycmd.trace "Attempting to register task '${fully_qualified_task_name}' with function '${task_function_name}'."

    if [[ -v _MYPROJECT_TASKS["${fully_qualified_task_name}"] ]]; then
        local existing_task_function_name="${_MYPROJECT_TASKS["${fully_qualified_task_name}"]}"

        if [[ "${existing_task_function_name}" != "${task_function_name}" ]]; then
            mycmd.debug "'${fully_qualified_task_name}' is already registered with function '${existing_task_function_name}', not '${task_function_name}'."
            return 1
        else
            mycmd.debug "'${fully_qualified_task_name}' is already registered."
            return 0
        fi
    fi

    _MYPROJECT_TASKS["${fully_qualified_task_name}"]="${task_function_name}"
    mycmd.trace "Successfully registered task '${fully_qualified_task_name}' with function '${task_function_name}'."
    return 0
}

function project:task_registry.get_task() {
    local -r fully_qualified_task_name="${1}"
    local -n task_struct_ref="${2}"

    mycmd.trace "Attempting to load task with fully qualified name '${fully_qualified_task_name}'."

    task_struct_ref=()

    if ! [[ -v _MYPROJECT_TASKS["${fully_qualified_task_name}"] ]]; then
        mycmd.debug "Task '${fully_qualified_task_name}' is not found."
        return 1
    fi

    mycmd.trace "Returning task definition:"
    task_struct_ref["${_TASK_FULLY_QUALIFIED_NAME_FIELD}"]="${fully_qualified_task_name}"
    mycmd.trace "- ${_TASK_FULLY_QUALIFIED_NAME_FIELD}: ${task_struct_ref["${_TASK_FULLY_QUALIFIED_NAME_FIELD}"]}"

    local task_name
    task_name="$(basename "${fully_qualified_task_name}")"
    readonly task_name
    task_struct_ref["${_TASK_NAME_FIELD}"]="${task_name}"
    mycmd.trace "- ${_TASK_NAME_FIELD}: ${task_struct_ref["${_TASK_NAME_FIELD}"]}"

    local -r namespaced_parts_string="${fully_qualified_task_name//\// }"
    task_struct_ref["${_TASK_NAMESPACED_PARTS_STRING_FIELD}"]="${namespaced_parts_string}"
    mycmd.trace "- ${_TASK_NAMESPACED_PARTS_STRING_FIELD}: ${task_struct_ref["${_TASK_NAMESPACED_PARTS_STRING_FIELD}"]}"

    task_struct_ref["${_TASK_FUNCTION_FIELD}"]="${_MYPROJECT_TASKS["${fully_qualified_task_name}"]}"
    mycmd.trace "- ${_TASK_FUNCTION_FIELD}: ${task_struct_ref["${_TASK_FUNCTION_FIELD}"]}"
}

function project:task_registry.list_tasks() {
    if (("${#_MYPROJECT_TASKS[@]}" == 0)); then
        mycmd.output "There are no registered tasks."
        return 0
    fi

    local -a sorted_task_names
    # shellcheck disable=SC2034
    readarray -t sorted_task_names < \
        <(printf '%s\n' "${!_MYPROJECT_TASKS[@]}" | LC_ALL=en_US.UTF-8 sort || true)

    mycmd.output "The following tasks are registered:"

    local task
    for task in "${sorted_task_names[@]}"; do
        mycmd.output "${task}"
    done
}

function project:task.get_fully_qualified_name() {
    project:task._get_field_from_struct \
        "${_TASK_FULLY_QUALIFIED_NAME_FIELD}" \
        "${@}"
}

function project:task.get_name() {
    project:task._get_field_from_struct \
        "${_TASK_NAME_FIELD}" \
        "${@}"
}

function project:task.get_namespaced_parts_as_string() {
    project:task._get_field_from_struct \
        "${_TASK_NAMESPACED_PARTS_STRING_FIELD}" \
        "${@}"
}

function project:task.get_function_name() {
    project:task._get_field_from_struct \
        "${_TASK_FUNCTION_FIELD}" \
        "${@}"
}

function project:task._get_field_from_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n task_struct_ref="${2}"

    if [[ -v task_struct_ref["${field_name}"] ]]; then
        echo "${task_struct_ref["${field_name}"]}"
        return 0
    else
        mycmd.debug "Missing required task field '${field_name}'."
        return 1
    fi
}

mycmd.trace "The MyCmd Project Task command group support library has been sourced."
