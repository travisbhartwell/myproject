# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyProject Task Command Group Support Library
#   Support for Task Definition Data Structures and Related Functions for MyProject

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    # coverage skip: 2
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_MYPROJECT_TASK_LIB:-}" ]] && return
readonly _MYPROJECT_TASK_LIB=1

mycmd:command_group.load_support_lib "execution"
mycmd:command_group.load_support_lib "fileset"
mycmd:command_group.load_support_lib "output"

declare -Agx _MYPROJECT_TASKS
declare -Agx _MYPROJECT_TASKS_TASK_DEFINITION_FILES
declare -Agx _MYPROJECT_TASKS_DESCRIPTIONS
declare -Agx _MYPROJECT_TASKS_ARGUMENT_COUNTS
declare -Agx _MYPROJECT_TASKS_ARGUMENT_INDICES
declare -agx _MYPROJECT_TASKS_ARGUMENTS
declare -Agx _MYPROJECT_TASKS_FILESETS
declare -Agx _MYPROJECT_LOADED_TASK_DEFINITION_FILES
declare -Agx _MYPROJECT_TASK_DEFINITION_FILE_DESCRIPTIONS

readonly _TASK_FULLY_QUALIFIED_NAME_FIELD='task-fully-qualified-name'
readonly _TASK_NAME_FIELD='task-name'
readonly _TASK_NAMESPACED_PARTS_STRING_FIELD='task-namespaced-parts-string'
readonly _TASK_DESCRIPTION_FIELD='task-description'
readonly _TASK_TASK_DEFINITION_FILE_FIELD='task-definition-file'
readonly _TASK_FUNCTION_FIELD='task-function'
readonly _TASK_ARGUMENT_COUNT_FIELD='task-argument-count'
readonly _TASK_ARGUMENT_INDEX_FIELD='task-argument-index'
readonly _TASK_FILESET_FIELD='task-fileset'

function project:task_registry._reset_registry() {
    mycmd.trace "Resetting the MyProject Task Registry."
    _MYPROJECT_TASKS=()
    _MYPROJECT_TASKS_TASK_DEFINITION_FILES=()
    _MYPROJECT_TASKS_DESCRIPTIONS=()
    _MYPROJECT_TASKS_ARGUMENT_COUNTS=()
    _MYPROJECT_TASKS_ARGUMENT_INDICES=()
    _MYPROJECT_TASKS_ARGUMENTS=()
    _MYPROJECT_TASKS_FILESETS=()
    _MYPROJECT_LOADED_TASK_DEFINITION_FILES=()
    _MYPROJECT_TASK_DEFINITION_FILE_DESCRIPTIONS=()
    unset MYPROJECT_ROOT_DIRECTORY
    unset MYPROJECT_TASK_DEFINITION_DIRECTORY

    project:fileset_registry._reset_registry
}

project:task_registry._reset_registry

function project:task_registry._dump_task_registry() {
    # coverage skip: 35
    if [[ ! -v MYPROJECT_ROOT_DIRECTORY && ! -v MYPROJECT_TASK_DEFINITION_DIRECTORY ]]; then
        mycmd.trace "Nothing is loaded in the registry."
    fi

    mycmd.trace "The project with root at '${MYPROJECT_ROOT_DIRECTORY}' and task definition directory '${MYPROJECT_TASK_DEFINITION_DIRECTORY}' is loaded."

    mycmd.trace "There are ${#_MYPROJECT_TASKS_TASK_DEFINITION_FILES[@]} task definition files loaded."

    local task_definition_file
    for task_definition_file in "${!_MYPROJECT_LOADED_TASK_DEFINITION_FILES[@]}"; do
        local task_definition_file_description
        if [[ -v _MYPROJECT_TASK_DEFINITION_FILE_DESCRIPTIONS["${task_definition_file}"] ]]; then
            task_definition_file_description="${_MYPROJECT_TASK_DEFINITION_FILE_DESCRIPTIONS["${task_definition_file}"]}"
            mycmd.trace "- ${task_definition_file}: ${task_definition_file_description}"
        else
            mycmd.trace "- ${task_definition_file}: No registered description."
        fi
    done

    mycmd.trace "There are ${#_MYPROJECT_TASKS[@]} tasks registered."

    local fully_qualified_task_name
    for fully_qualified_task_name in "${!_MYPROJECT_TASKS[@]}"; do
        mycmd.trace "The task with fully qualified name '${fully_qualified_task_name}' is registered."
        mycmd.trace "It is registered with task definition file: '${_MYPROJECT_TASKS_TASK_DEFINITION_FILES["${fully_qualified_task_name}"]}'."
        mycmd.trace "It is registered with task function '${_MYPROJECT_TASKS["${fully_qualified_task_name}"]}'."

        if [[ -v _MYPROJECT_TASKS_DESCRIPTIONS["${fully_qualified_task_name}"] ]]; then
            mycmd.trace "It is registred with the description '${_MYPROJECT_TASKS_DESCRIPTIONS["${fully_qualified_task_name}"]}'."
        fi

        mycmd.trace "-------------------------"
    done
}

function project:task_registry.get_registered_task_count() {
    echo "${#_MYPROJECT_TASKS[@]}"
}

function project:task_registry.load_task_definition_file() {
    local -r project_root_directory="${1}"
    local -r task_definition_directory="${2}"
    local -r task_definition_file_name="${3}"

    declare -gx MYPROJECT_ROOT_DIRECTORY="${project_root_directory}"
    declare -gx MYPROJECT_TASK_DEFINITION_DIRECTORY="${task_definition_directory}"

    project:task_registry._load_task_definition_file "${task_definition_file_name}"
}

function project:task_registry.load_all_task_definition_files() {
    local -r project_root_directory="${1}"
    local -r task_definition_directory="${2}"

    # First load main
    if ! project:task_registry.load_task_definition_file "${project_root_directory}" "${task_definition_directory}" main; then
        mycmd.error_output "Error loading main task definition file."
        return 1
    fi

    local -a task_definition_files=("${task_definition_directory}"/*)

    local task_definition_file_path
    local task_definition_file_name

    for task_definition_file_path in "${task_definition_files[@]}"; do
        task_definition_file_name="$(basename "${task_definition_file_path}")"

        mycmd.trace "Attempting to load task definition file '${task_definition_file_name}'."

        if ! project:task_registry.load_task_definition_file "${project_root_directory}" "${task_definition_directory}" "${task_definition_file_name}"; then
            mycmd.error_output "Error loading task definition file name '${task_definition_file_name}'."
            return 1
        fi
    done
}

function project:task_registry._load_task_definition_file() {
    if [[ ! -v MYPROJECT_ROOT_DIRECTORY && ! -v MYPROJECT_TASK_DEFINITION_DIRECTORY ]]; then
        # coverage skip: 2
        mycmd.debug "Error: MYPROJECT_ROOT DIRECTORY and MYPROJECT_TASK_DEFINITION_DIRECTORY must be set."
        return 1
    fi

    local -r task_definition_file_name="${1}"

    if [[ -v _MYPROJECT_LOADED_TASK_DEFINITION_FILES[${task_definition_file_name}] ]]; then
        mycmd.trace "'${task_definition_file_name}' already loaded."
        return 0
    fi

    mycmd.trace "Loading '${task_definition_file_name}' from task definition directory '${MYPROJECT_TASK_DEFINITION_DIRECTORY}' for project '${MYPROJECT_ROOT_DIRECTORY}'."

    declare -gx MYPROJECT_CURRENT_TASK_FILE="${task_definition_file_name}"

    local -r task_definition_file="${MYPROJECT_TASK_DEFINITION_DIRECTORY}/${task_definition_file_name}"

    local result=0
    if ! mycmd.source_lib_by_path_if_found "${task_definition_file}"; then
        mycmd.error_output "Error loading task definition file '${task_definition_file}'."
        result=1
    fi

    unset MYPROJECT_CURRENT_TASK_FILE

    if ((result != 0)); then
        return "${result}"
    fi

    _MYPROJECT_LOADED_TASK_DEFINITION_FILES[${task_definition_file_name}]=1

    return 0
}

function project:task_registry.register_task_file_description() {
    if [[ ! -v MYPROJECT_CURRENT_TASK_FILE ]]; then
        # coverage skip: 2
        mycmd.debug "Error: MYPROJECT_CURRENT_TASK_FILE must be set."
        return 1
    fi

    mycmd.trace "Attempting to register task file description for task definition file '${MYPROJECT_CURRENT_TASK_FILE}'."

    local -r task_file_description="${1}"

    if [[ -v _MYPROJECT_TASK_DEFINITION_FILE_DESCRIPTIONS["${MYPROJECT_CURRENT_TASK_FILE}"] ]]; then
        local -r existing_description="${_MYPROJECT_TASK_DEFINITION_FILE_DESCRIPTIONS["${MYPROJECT_CURRENT_TASK_FILE}"]}"

        mycmd.error_output "Task definition file description already registered: '${existing_description}'."
        return 1
    fi

    _MYPROJECT_TASK_DEFINITION_FILE_DESCRIPTIONS["${MYPROJECT_CURRENT_TASK_FILE}"]="${task_file_description}"

    mycmd.trace "Successfully registered task file description for task definition file '${MYPROJECT_CURRENT_TASK_FILE}': '${task_file_description}'."
}

function project:task_definition_file.get_description() {
    local -r task_definition_file_name="${1}"

    local task_file_description
    if [[ -v _MYPROJECT_TASK_DEFINITION_FILE_DESCRIPTIONS["${task_definition_file_name}"] ]]; then
        task_file_description="${_MYPROJECT_TASK_DEFINITION_FILE_DESCRIPTIONS["${task_definition_file_name}"]}"
        readonly task_file_description
        echo "${task_file_description}"
        return 0
    fi

    mycmd.debug "No task file description registered for task definition file '${task_definition_file_name}'."

    return 1
}

function project:task_registry.new_task() {
    local -r task_definition_file_name="${1}"

    local fully_qualified_task_name
    fully_qualified_task_name="$(project:task_registry._get_filtered_fully_qualified_task_name "${2}")"
    readonly fully_qualified_task_name

    local -r task_function_name="${3}"
    shift 3

    local -r argc="$#"

    mycmd.trace "Attempting to register task '${fully_qualified_task_name}' with function '${task_function_name}'."

    if [[ -v _MYPROJECT_TASKS["${fully_qualified_task_name}"] ]]; then
        local existing_task_function_name="${_MYPROJECT_TASKS["${fully_qualified_task_name}"]}"

        if [[ "${existing_task_function_name}" != "${task_function_name}" ]]; then
            mycmd.error_output "'${fully_qualified_task_name}' is already registered with function '${existing_task_function_name}', not '${task_function_name}'."
            return 1
        else
            mycmd.debug "'${fully_qualified_task_name}' is already registered."
            return 0
        fi
    fi

    if ! mycmd.function_exists "${task_function_name}"; then
        mycmd.error_output "Task function '${task_function_name}' for '${fully_qualified_task_name}' does not exist."
        return 1
    fi

    local task_name
    task_name="$(basename "${fully_qualified_task_name}")"
    readonly task_name

    if project:task_registry._task_definition_file_exists "${task_name}"; then
        mycmd.error_output "Cannot name task '${task_name}' which is the same as an existing task definition file name."
        return 1
    fi

    _MYPROJECT_TASKS["${fully_qualified_task_name}"]="${task_function_name}"
    _MYPROJECT_TASKS_TASK_DEFINITION_FILES["${fully_qualified_task_name}"]="${task_definition_file_name}"
    _MYPROJECT_TASKS_ARGUMENT_COUNTS["${fully_qualified_task_name}"]="${argc}"

    if ((argc > 0)); then
        local index="${#_MYPROJECT_TASKS_ARGUMENTS[@]}"
        _MYPROJECT_TASKS_ARGUMENTS+=("${@}")
        _MYPROJECT_TASKS_ARGUMENT_INDICES["${fully_qualified_task_name}"]="${index}"

        mycmd.trace "Created task arguments for task '${fully_qualified_task_name}' at index ${index} with argument count ${argc}."
    else
        mycmd.trace "Registered 0 arguments for task '${fully_qualified_task_name}'."
    fi

    mycmd.trace "Successfully registered task '${fully_qualified_task_name}' from task definition file '${task_definition_file_name}' with function '${task_function_name}' with ${argc} arguments."
    return 0
}

function project:task_registry.new_task_with_fileset() {
    local -r task_definition_file_name="${1}"

    local fully_qualified_task_name
    fully_qualified_task_name="$(project:task_registry._get_filtered_fully_qualified_task_name "${2}")"
    readonly fully_qualified_task_name

    local -r task_function_name="${3}"
    local -r fileset_name="${4}"
    shift 4

    if ! project:fileset_registry._fileset_exists "${fileset_name}"; then
        mycmd.error_output "Fileset '${fileset_name}' for task '${fully_qualified_task_name}' does not exist."
        return 1
    fi

    if ! project:task_registry.new_task \
        "${task_definition_file_name}" \
        "${fully_qualified_task_name}" \
        "${task_function_name}" \
        "${@}"; then
        return 1
    fi

    _MYPROJECT_TASKS_FILESETS["${fully_qualified_task_name}"]="${fileset_name}"

    mycmd.trace "Successfully registered fileset '${fileset_name}' for task '${fully_qualified_task_name}'."
}

function project:task_registry._task_definition_file_exists() {
    if [[ ! -v MYPROJECT_TASK_DEFINITION_DIRECTORY ]]; then
        # coverage skip: 2
        mycmd.debug "Error: MYPROJECT_TASK_DEFINITION_DIRECTORY must be set."
        return 1
    fi

    local -r task_definition_file_name="${1}"

    [[ -e "${MYPROJECT_TASK_DEFINITION_DIRECTORY}/${task_definition_file_name}" ]]
}

function project:task_registry.register_task_description() {
    local fully_qualified_task_name
    fully_qualified_task_name="$(project:task_registry._get_filtered_fully_qualified_task_name "${1}")"
    readonly fully_qualified_task_name

    local -r task_description="${2}"

    mycmd.trace "Attempting to register description '${task_description}' for task '${fully_qualified_task_name}'."

    if ! project:task_registry.task_exists_with_fully_qualified_task_name "${fully_qualified_task_name}"; then
        mycmd.error_output "Task '${fully_qualified_task_name}' does not exist for description registration."
        return 1
    fi

    if [[ -v _MYPROJECT_TASKS_DESCRIPTIONS["${fully_qualified_task_name}"] ]]; then
        local -r existing_task_description="${_MYPROJECT_TASKS_DESCRIPTIONS["${fully_qualified_task_name}"]}"

        if [[ "${existing_task_description}" != "${task_description}" ]]; then
            mycmd.error_output "Task '${fully_qualified_task_name}' already has description '${existing_task_description}'."
            return 1
        else
            mycmd.trace "Task description '${task_description}' already registered for task '${fully_qualified_task_name}'."
            return 0
        fi
    fi

    _MYPROJECT_TASKS_DESCRIPTIONS["${fully_qualified_task_name}"]="${task_description}"

    mycmd.trace "Successfully registered description '${task_description}' for task '${fully_qualified_task_name}'."

    return 0
}

function project:task_registry.get_task() {
    local fully_qualified_task_name
    fully_qualified_task_name="$(project:task_registry._get_filtered_fully_qualified_task_name "${1}")"
    readonly fully_qualified_task_name

    local -n task_struct_ref="${2}"

    mycmd.trace "Attempting to get task with fully qualified name '${fully_qualified_task_name}'."

    task_struct_ref=()

    if ! project:task_registry.task_exists_with_fully_qualified_task_name "${fully_qualified_task_name}"; then
        return 1
    fi

    mycmd.trace "Returning task definition:"
    task_struct_ref["${_TASK_FULLY_QUALIFIED_NAME_FIELD}"]="${fully_qualified_task_name}"
    mycmd.trace "- ${_TASK_FULLY_QUALIFIED_NAME_FIELD}: ${task_struct_ref["${_TASK_FULLY_QUALIFIED_NAME_FIELD}"]}"

    local task_name
    task_name="$(basename "${fully_qualified_task_name}")"
    readonly task_name
    task_struct_ref["${_TASK_NAME_FIELD}"]="${task_name}"
    mycmd.trace "- ${_TASK_NAME_FIELD}: ${task_struct_ref["${_TASK_NAME_FIELD}"]}"

    local -r namespaced_parts_string="${fully_qualified_task_name//\// }"
    task_struct_ref["${_TASK_NAMESPACED_PARTS_STRING_FIELD}"]="${namespaced_parts_string}"
    mycmd.trace "- ${_TASK_NAMESPACED_PARTS_STRING_FIELD}: ${task_struct_ref["${_TASK_NAMESPACED_PARTS_STRING_FIELD}"]}"

    if [[ -v _MYPROJECT_TASKS_DESCRIPTIONS["${fully_qualified_task_name}"] ]]; then
        local -r task_description="${_MYPROJECT_TASKS_DESCRIPTIONS["${fully_qualified_task_name}"]}"
        task_struct_ref["${_TASK_DESCRIPTION_FIELD}"]="${task_description}"
        mycmd.trace "- ${_TASK_DESCRIPTION_FIELD}: ${task_struct_ref["${_TASK_DESCRIPTION_FIELD}"]}"
    else
        mycmd.trace "- ${_TASK_DESCRIPTION_FIELD}: No value set."
    fi

    task_struct_ref["${_TASK_TASK_DEFINITION_FILE_FIELD}"]="${_MYPROJECT_TASKS_TASK_DEFINITION_FILES["${fully_qualified_task_name}"]}"
    mycmd.trace "- ${_TASK_TASK_DEFINITION_FILE_FIELD}: ${task_struct_ref["${_TASK_TASK_DEFINITION_FILE_FIELD}"]}"

    task_struct_ref["${_TASK_FUNCTION_FIELD}"]="${_MYPROJECT_TASKS["${fully_qualified_task_name}"]}"
    mycmd.trace "- ${_TASK_FUNCTION_FIELD}: ${task_struct_ref["${_TASK_FUNCTION_FIELD}"]}"

    local -r argc="${_MYPROJECT_TASKS_ARGUMENT_COUNTS["${fully_qualified_task_name}"]}"
    task_struct_ref["${_TASK_ARGUMENT_COUNT_FIELD}"]="${argc}"
    mycmd.trace "- ${_TASK_ARGUMENT_COUNT_FIELD}: ${task_struct_ref["${_TASK_ARGUMENT_COUNT_FIELD}"]}"

    if (("${argc}" > 0)); then
        if ! [[ -v _MYPROJECT_TASKS_ARGUMENT_INDICES["${fully_qualified_task_name}"] ]]; then
            # coverage skip: 2
            mycmd.debug "Required argument indices data missing for '${fully_qualified_task_name}'."
            return 1
        fi

        task_struct_ref["${_TASK_ARGUMENT_INDEX_FIELD}"]="${_MYPROJECT_TASKS_ARGUMENT_INDICES["${fully_qualified_task_name}"]}"
        mycmd.trace "- ${_TASK_ARGUMENT_INDEX_FIELD}: ${task_struct_ref["${_TASK_ARGUMENT_INDEX_FIELD}"]}"
    else
        mycmd.trace "- ${_TASK_ARGUMENT_INDEX_FIELD}: No value set."
    fi

    if [[ -v _MYPROJECT_TASKS_FILESETS["${fully_qualified_task_name}"] ]]; then
        local -r fileset="${_MYPROJECT_TASKS_FILESETS["${fully_qualified_task_name}"]}"
        task_struct_ref["${_TASK_FILESET_FIELD}"]="${fileset}"
        mycmd.trace "- ${_TASK_FILESET_FIELD}: ${task_struct_ref["${_TASK_FILESET_FIELD}"]}"
    else
        mycmd.trace "- ${_TASK_FILESET_FIELD}: No value set."
    fi
}

function project:task_registry._get_filtered_fully_qualified_task_name() {
    local -r fully_qualified_task_name="${1}"

    echo "${fully_qualified_task_name##main/}"
}

function project:task_registry.task_exists_with_fully_qualified_task_name() {
    local fully_qualified_task_name
    fully_qualified_task_name="$(project:task_registry._get_filtered_fully_qualified_task_name "${1}")"
    readonly fully_qualified_task_name

    mycmd.trace "Attempting to locate task with fully qualified name '${fully_qualified_task_name}'."

    if ! [[ -v _MYPROJECT_TASKS["${fully_qualified_task_name}"] ]]; then
        mycmd.debug "Task '${fully_qualified_task_name}' is not found."
        return 1
    fi

    return 0
}

function project:task_registry.foreach_task_definition_file() {
    local -a task_definition_files
    project:task_registry._get_all_task_definition_files task_definition_files

    local task_definition_file_name
    for task_definition_file_name in "${task_definition_files[@]}"; do
        "${@}" "${task_definition_file_name}"
    done

    return 0
}

function project:task_registry.foreach_task_by_task_definition_file() {
    local -a task_definition_files
    project:task_registry._get_all_task_definition_files task_definition_files

    local task_definition_file_name
    for task_definition_file_name in "${task_definition_files[@]}"; do
        project:task_registry.foreach_task_in_task_definition_file "${task_definition_file_name}" "${@}"
    done

    return 0
}

function project:task_registry._get_all_task_definition_files() {
    local -n task_definition_files_ref="${1}"

    if (("${#_MYPROJECT_LOADED_TASK_DEFINITION_FILES[@]}" == 0)); then
        # coverage skip: 2
        task_definition_files_ref=()
        return 0
    fi

    task_definition_files_ref+=("main")

    local -a other_files=()
    local task_definition_file_name

    for task_definition_file_name in "${!_MYPROJECT_LOADED_TASK_DEFINITION_FILES[@]}"; do
        if [[ "${task_definition_file_name}" != "main" ]]; then
            other_files+=("${task_definition_file_name}")
        fi
    done

    readarray -t -O 1 task_definition_files_ref < \
        <(printf '%s\n' "${other_files[@]}" | LC_ALL=en_US.UTF-8 sort || true)

    return 0
}

function project:task_registry.foreach_task_in_task_definition_file() {
    local -r task_definition_file_name="${1}"
    shift

    local -a tasks
    project:task_registry._get_all_tasks_for_task_definition_file "${task_definition_file_name}" tasks

    local fully_qualified_task_name
    for fully_qualified_task_name in "${tasks[@]}"; do
        "${@}" "${fully_qualified_task_name}"
    done

    return 0
}

function project:task_registry._get_all_tasks_for_task_definition_file() {
    local -r wanted_task_definition_file_name="${1}"
    local -n tasks_ref="${2}"

    local -a tasks_in_file=()

    local fully_qualified_task_name
    local task_definition_file_name

    for fully_qualified_task_name in "${!_MYPROJECT_TASKS_TASK_DEFINITION_FILES[@]}"; do
        task_definition_file_name="${_MYPROJECT_TASKS_TASK_DEFINITION_FILES["${fully_qualified_task_name}"]}"

        if [[ "${task_definition_file_name}" = "${wanted_task_definition_file_name}" ]]; then
            tasks_in_file+=("${fully_qualified_task_name}")
        fi
    done

    # shellcheck disable=SC2034
    readarray -t tasks_ref < \
        <(printf '%s\n' "${tasks_in_file[@]}" | LC_ALL=en_US.UTF-8 sort || true)

    return 0
}

function project:task.get_fully_qualified_name() {
    project:task._get_field_from_struct \
        "${_TASK_FULLY_QUALIFIED_NAME_FIELD}" \
        "${@}"
}

function project:task.get_name() {
    project:task._get_field_from_struct \
        "${_TASK_NAME_FIELD}" \
        "${@}"
}

function project:task.get_namespaced_parts_as_string() {
    project:task._get_field_from_struct \
        "${_TASK_NAMESPACED_PARTS_STRING_FIELD}" \
        "${@}"
}

function project:task.get_description() {
    project:task._get_field_from_struct \
        "${_TASK_DESCRIPTION_FIELD}" \
        "${@}"
}

function project:task.get_task_definition_file_name() {
    project:task._get_field_from_struct \
        "${_TASK_TASK_DEFINITION_FILE_FIELD}" \
        "${@}"
}

function project:task.get_function_name() {
    project:task._get_field_from_struct \
        "${_TASK_FUNCTION_FIELD}" \
        "${@}"
}

function project:task.get_argument_count() {
    project:task._get_field_from_struct \
        "${_TASK_ARGUMENT_COUNT_FIELD}" \
        "${@}"
}

function project:task.get_argument_index() {
    project:task._get_field_from_struct \
        "${_TASK_ARGUMENT_INDEX_FIELD}" \
        "${@}"
}

function project:task.get_fileset() {
    project:task._get_field_from_struct \
        "${_TASK_FILESET_FIELD}" \
        "${@}"
}

function project:task._get_field_from_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n task_struct_ref="${2}"

    if [[ -v task_struct_ref["${field_name}"] ]]; then
        echo "${task_struct_ref["${field_name}"]}"
        return 0
    else
        mycmd.debug "Missing required task field '${field_name}'."
        return 1
    fi
}

function project:task.get_arguments() {
    # shellcheck disable=SC2178
    local -n task_struct_ref="${1}"
    local -n arguments_ref="${2}"

    local fully_qualified_task_name
    fully_qualified_task_name="$(project:task.get_fully_qualified_name "${!task_struct_ref}")"
    readonly fully_qualified_task_name

    local -i argc
    argc="$(project:task.get_argument_count "${!task_struct_ref}")"
    readonly argc

    if ((argc == 0)); then
        mycmd.trace "No arguments defined for task '${fully_qualified_task_name}'."
        # shellcheck disable=SC2034
        arguments_ref=()
        return 0
    fi

    local -i index
    if ! index="$(project:task.get_argument_index "${!task_struct_ref}")"; then
        # coverage skip: 2
        mycmd.error_output "Unexpected error: index should be set for task '${fully_qualified_task_name}'."
        return 1
    fi
    readonly index

    arguments_ref=("${_MYPROJECT_TASKS_ARGUMENTS[@]:index:argc}")
    mycmd.trace "Set arguments for '${fully_qualified_task_name}' in ${!arguments_ref} as ${arguments_ref[*]}."
}

function project:task.execute() {
    # shellcheck disable=SC2178
    local -n task_struct_ref="${1}"
    shift

    local task_function_name
    task_function_name="$(project:task.get_function_name "${!task_struct_ref}")"
    readonly task_function_name

    local namespaced_parts_string
    namespaced_parts_string="$(project:task.get_namespaced_parts_as_string "${!task_struct_ref}")"
    readonly namespaced_parts_string

    local task_definition_file_name
    task_definition_file_name="$(project:task.get_task_definition_file_name "${!task_struct_ref}")"
    readonly task_definition_file_name

    local -a task_arguments=()
    project:task.get_arguments "${!task_struct_ref}" task_arguments
    set -- "${task_arguments[@]}" "${@}"

    declare -gx MYPROJECT_CURRENT_TASK_FILE="${task_definition_file_name}"

    local task_description
    if task_description="$(project:task.get_description "${!task_struct_ref}")"; then
        readonly task_description
    fi

    if project.is_verbose_enabled && [[ -n "${task_description-}" ]]; then
        mycmd.output "➡️ Executing task '${namespaced_parts_string}': ${task_description}..."
    else
        mycmd.output "➡️ Executing task '${namespaced_parts_string}'..."
    fi

    local return_code=0

    local fileset_name
    if fileset_name="$(project:task.get_fileset "${!task_struct_ref}")"; then
        set -- "${fileset_name}" "${@}"
    fi
    readonly fileset_name

    "${task_function_name}" "${@}" || return_code="${?}"

    if ((return_code == 0)); then
        mycmd.output "✅ Task '${namespaced_parts_string}' succeeded."
    else
        mycmd.output "❌ Task '${namespaced_parts_string}' failed."
    fi

    return "${return_code}"
}

mycmd.trace "The MyProject Task command group support library has been sourced."
