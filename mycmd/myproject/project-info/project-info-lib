# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyProject Project Info Project Command Group

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    # coverage skip: 2
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_PROJECT_INFO_LIB:-}" ]] && return
readonly _PROJECT_INFO_LIB=1

function project_info.get_project_root_directory() {
    local -a project_directories
    if ! project.find_up project_directories "${PWD}"; then
        mycmd.error_output "Not located in a MyProject Project."
        return 1
    fi

    echo "${project_directories["${_PROJECT_ROOT_DIRECTORY}"]}"
}

function project_info.get_project_task_definition_directory() {
    local -a project_directories
    if ! project.find_up project_directories "${PWD}"; then
        mycmd.error_output "Not located in a MyProject Project."
        return 1
    fi

    echo "${project_directories["${_PROJECT_TASK_DEFINITION_DIRECTORY}"]}"
}

readonly PROJECT_INFO_FORMAT_PLAIN='plain'
readonly PROJECT_INFO_FORMAT_TABLE='table'

declare -Agx PROJECT_INFO_OUTPUT_DISPATCH
PROJECT_INFO_OUTPUT_DISPATCH["${PROJECT_INFO_FORMAT_PLAIN}"]="_plain_format"
PROJECT_INFO_OUTPUT_DISPATCH["${PROJECT_INFO_FORMAT_TABLE}"]="_table_format"

readonly PROJECT_INFO_ARGS_FORMAT='format'
readonly PROJECT_INFO_ARGS_OUTPUT_FN='output-fn'
readonly PROJECT_INFO_ARGS_QUIET='quiet'
readonly PROJECT_INFO_ARGS_UNKNOWN='unknown'

function project_info.parse_format_command_line() {
    local -n arguments_ref="${1}"
    local -r output_fn_prefix="${2}"
    shift 2

    local -A errors=()

    # Set defaults
    arguments_ref["${PROJECT_INFO_ARGS_QUIET}"]=false
    arguments_ref["${PROJECT_INFO_ARGS_FORMAT}"]="${PROJECT_INFO_FORMAT_TABLE}"

    while (($# > 0)); do
        case "${1}" in
            "--${PROJECT_INFO_ARGS_QUIET}" | "-q")
                arguments_ref["${PROJECT_INFO_ARGS_QUIET}"]=true
                shift
                ;;

            "--${PROJECT_INFO_ARGS_FORMAT}"* | "-f")
                local format

                if [[ "${1}" =~ --${PROJECT_INFO_ARGS_FORMAT}=.+ ]]; then
                    format=${1##*"${PROJECT_INFO_ARGS_FORMAT}"=}
                    shift
                elif [[ "${#}" -ge 2 && "${2:0:1}" != "-" ]]; then
                    format="${2}"
                    shift 2
                else
                    mycmd.error_output "Missing argument for '--${PROJECT_INFO_ARGS_FORMAT}'."
                    errors["${PROJECT_INFO_ARGS_FORMAT}"]=1
                    shift
                fi

                if [[ -v format ]]; then
                    if [[ -v PROJECT_INFO_OUTPUT_DISPATCH["${format}"] ]]; then
                        arguments_ref["${PROJECT_INFO_ARGS_FORMAT}"]="${format}"
                    else
                        project_info.print_unknown_format_message "${format}"
                        errors["${PROJECT_INFO_ARGS_FORMAT}"]=1
                    fi
                fi
                ;;

            *)
                mycmd.error_output "Unknown flag or argument: '${1}'."
                errors["${PROJECT_INFO_ARGS_UNKNOWN}"]=1
                shift
                ;;
        esac
    done

    local -r format="${arguments_ref["${PROJECT_INFO_ARGS_FORMAT}"]}"
    local -r format_dispatch="${PROJECT_INFO_OUTPUT_DISPATCH["${format}"]}"
    arguments_ref["${PROJECT_INFO_ARGS_OUTPUT_FN}"]="${output_fn_prefix}${format_dispatch}"

    local command_name
    # shellcheck disable=SC2154
    command_name=$(basename "${_MYCMD_FULLY_QUALIFIED_NAME}")
    readonly command_name

    mycmd.trace "Parsed command line arguments for ${command_name}:"
    local argument

    for argument in \
        "${PROJECT_INFO_ARGS_QUIET}" \
        "${PROJECT_INFO_ARGS_FORMAT}" \
        "${PROJECT_INFO_ARGS_OUTPUT_FN}"; do
        mycmd.trace "${argument} = ${arguments_ref[${argument}]}"
    done

    (("${#errors[@]}" == 0))
}

function project_info.print_unknown_format_message() {
    local -r supplied_format="${1}"

    mycmd.error_output "Unknown output format '${supplied_format}', the following options are available:"

    local format
    for format in "${!PROJECT_INFO_OUTPUT_DISPATCH[@]}"; do
        mycmd.error_output "- ${format}"
    done
}

function project_info.enable_quiet_mode_if_set_in_arguments() {
    # shellcheck disable=SC2178
    local -n arguments_ref="${1}"

    if [[ "${arguments_ref["${PROJECT_INFO_ARGS_QUIET}"]}" = "true" ]]; then
        project.enable_quiet_mode
    fi
}

function project_info.call_output_fn_from_arguments() {
    # shellcheck disable=SC2178
    local -n arguments_ref="${1}"

    local -r output_fn="${arguments_ref["${PROJECT_INFO_ARGS_OUTPUT_FN}"]}"

    "${output_fn}"
}

function project_info.list_tasks_plain_format() {
    project_info.list_tasks project:task_registry.foreach_task_by_task_definition_file project_info.print_task_namespaced_parts_string
}

function project_info.list_tasks_table_format() {
    project_info.list_tasks project:task_registry.foreach_task_definition_file project_info.summarize_task_definition_file_tasks
}

function project_info.summarize_task_definition_file_tasks() {
    local -r task_definition_file_name="${1}"

    local summary_table_heading

    local task_definition_file_description
    if task_definition_file_description="$(project:task_definition_file.get_description "${task_definition_file_name}")"; then
        summary_table_heading="The folowing tasks are defined in the task definition file '${task_definition_file_name}': ${task_definition_file_description}:"
    else
        summary_table_heading="The folowing tasks are defined in the task definition file '${task_definition_file_name}':"
    fi
    readonly summary_table_heading

    # shellcheck disable=SC2034
    local -A task_summary_table=()
    project:task_registry.foreach_task_in_task_definition_file "${task_definition_file_name}" \
        project_info.add_task_summary_to_table task_summary_table

    mycmd.print_table task_summary_table \
        "${summary_table_heading}" \
        "Task Name" "Description"
}

function project_info.add_task_summary_to_table() {
    local -n task_summary_table_ref="${1}"
    local -r fully_qualified_task_name="${2}"

    # shellcheck disable=SC2034
    local -A task
    if ! project:task_registry.get_task "${fully_qualified_task_name}" task; then
        # coverage skip: 2
        mycmd.debug "Unexpected error getting task '${fully_qualified_task_name}'."
        return 1
    fi

    local namespaced_parts_string
    namespaced_parts_string="$(project:task.get_namespaced_parts_as_string task)"

    local task_description
    if ! task_description="$(project:task.get_description task)"; then
        task_description=""
    fi
    readonly task_description

    # shellcheck disable=SC2034
    task_summary_table_ref["${namespaced_parts_string}"]="${task_description}"
}

function project_info.list_tasks() {
    local registered_task_count
    registered_task_count="$(project:task_registry.get_registered_task_count)"
    readonly registered_task_count

    if ((registered_task_count == 0)); then
        project.output_only_if_not_quiet "There are no registered tasks."
        return 0
    fi

    project.output_only_if_not_quiet "The following tasks are registered:"

    "${@}"
}

function project_info.print_task_namespaced_parts_string() {
    local -r fully_qualified_task_name="${1}"

    # shellcheck disable=SC2034
    local -A task
    if ! project:task_registry.get_task "${fully_qualified_task_name}" task; then
        # coverage skip: 2
        mycmd.debug "Unexpected error getting task '${fully_qualified_task_name}'."
        return 1
    fi

    local namespaced_parts_string
    namespaced_parts_string="$(project:task.get_namespaced_parts_as_string task)"

    mycmd.output "${namespaced_parts_string}"
}

readonly TASK_DEFINITION_FILES_HEADLINE="The MyProject project has the following task definition files:"

function project_info.list_task_definition_files_plain_format() {
    project.output_only_if_not_quiet "${TASK_DEFINITION_FILES_HEADLINE}"

    project:task_registry.foreach_task_definition_file mycmd.output
}

function project_info.list_task_definition_files_table_format() {
    # shellcheck disable=SC2034
    local -A task_definition_files_summary_table=()
    project:task_registry.foreach_task_definition_file \
        project_info._add_task_definition_file_summary_to_table task_definition_files_summary_table

    # TODO Use option when added to not sort the table
    mycmd.print_table task_definition_files_summary_table \
        "${TASK_DEFINITION_FILES_HEADLINE}" \
        "Task Definition File" "Description"
}

function project_info._add_task_definition_file_summary_to_table() {
    local -n task_definition_files_summary_table_ref="${1}"
    local -r task_definition_file_name="${2}"

    local task_definition_file_description
    if ! task_definition_file_description="$(project:task_definition_file.get_description "${task_definition_file_name}")"; then
        task_definition_file_description=""
    fi
    readonly task_definition_file_description

    # shellcheck disable=SC2034
    task_definition_files_summary_table_ref["${task_definition_file_name}"]="${task_definition_file_description}"
}

readonly FILESETS_HEADLINE="The MyProject project has the following registered filesets:"
readonly NO_FILESETS_HEADLINE="The MyProject project has no registered filesets."

function project_info.list_filesets_plain_format() {
    local registered_fileset_count
    registered_fileset_count="$(project:fileset_registry.get_fileset_count)"
    readonly registered_fileset_count

    if ((registered_fileset_count == 0)); then
        project.output_only_if_not_quiet "${NO_FILESETS_HEADLINE}"
        return 0
    fi

    project.output_only_if_not_quiet "${FILESETS_HEADLINE}"

    project:fileset_registry.foreach_fileset mycmd.output
}

function project_info.list_filesets_table_format() {
    local registered_fileset_count
    registered_fileset_count="$(project:fileset_registry.get_fileset_count)"
    readonly registered_fileset_count

    if ((registered_fileset_count == 0)); then
        project.output_only_if_not_quiet "${NO_FILESETS_HEADLINE}"
        return 0
    fi

    # shellcheck disable=SC2034
    local -A filesets_summary_table=()
    project:fileset_registry.foreach_fileset project_info._add_fileset_summary_to_table filesets_summary_table

    mycmd.print_table filesets_summary_table \
        "${FILESETS_HEADLINE}" \
        "File Set" "File Count"
}

function project_info._add_fileset_summary_to_table() {
    local -n filesets_summary_table_ref="${1}"
    local -r fileset="${2}"

    local file_count
    file_count="$(project:fileset.get_file_count "${fileset}")"
    readonly file_count

    # shellcheck disable=SC2034
    filesets_summary_table_ref["${fileset}"]="${file_count}"
}

mycmd.trace "The MyProject Project Info command group library has been sourced."
