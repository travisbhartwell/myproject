# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyProject Execution Command Group Support Library
#   Task Execution Support Library

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    # coverage skip: 2
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_MYPROJECT_EXECUTION_LIB:-}" ]] && return
readonly _MYPROJECT_EXECUTION_LIB=1

mycmd:command_group.load_support_lib "task"

# --------------------------------------------------------------------------------------------------
# Task Execution
function project.execute_task() {
    # shellcheck disable=SC2034
    local -A execution_task=()

    if ! project:execution_task.parse_from_arguments execution_task "${@}"; then
        mycmd.trace "Error getting task for arguments '${*}'."
        return 1
    fi

    local fully_qualified_task_name
    fully_qualified_task_name="$(project:execution_task.get_fully_qualified_task_name execution_task)"
    readonly fully_qualified_task_name

    local shift_amount
    shift_amount="$(project:execution_task.get_shift_amount execution_task)"
    readonly shift_amount
    shift "${shift_amount}"

    # shellcheck disable=SC2034
    local -A task=()

    if ! project:task_registry.get_task "${fully_qualified_task_name}" task; then
        mycmd.error_output "Error loading task '${fully_qualified_task_name}'."
        return 1
    fi

    local return_code=0

    project:task.execute task "${@}" || return_code="${?}"

    return "${return_code}"
}

function project.execute_tasks() {
    local -a task_positions=()
    local -a arguments=("${@}")

    if ! project._extract_task_positions task_positions "${arguments[@]}"; then
        mycmd.error_output "No tasks provided"
        return 1
    fi

    local -i max_argument_index="${#arguments[@]}"
    local -i max_task_index=$((${#task_positions[@]} - 1))

    local -i index
    local -i next_index
    local -i start
    local -i end
    local -i len

    mycmd.trace "Executing tasks from arguments: '${arguments[*]}'"

    for ((index = 0; index <= max_task_index; index++)); do
        start="${task_positions["${index}"]}"

        if ((index < max_task_index)); then
            next_index="$((index + 1))"
            end=$((${task_positions["${next_index}"]} - 1))
        else
            end="${max_argument_index}"
        fi

        len=$((end - start))

        mycmd.trace "Task ${index} start at ${start}, end at ${end}, argument length '${len}'."

        set -- "${arguments[@]:start:len}"

        mycmd.trace "Task arguments: '${*}'"

        local result=0

        project.execute_task "${@}" || result="${?}"

        if ((result != 0)); then
            return "${result}"
        fi
    done
}

## An execution task object is the result of parsing a task execution argument list, it contains two fields:
## - the fully qualified task name of the task referenced
readonly _EXECUTION_TASK_FULLY_QUALIFIED_NAME_FIELD='task-fully-qualified-name'
## - the amount of arguments to shift in the original argument list to get to the task arguments
readonly _EXECUTION_TASK_ARGUMENT_SHIFT_AMOUNT_FIELD='argument-shift-amount'

readonly _EXECUTION_TASK_MATCH_ARG1_AND_ARG2_NAME='arg1-and-arg2-name-matches'
readonly _EXECUTION_TASK_MATCH_TASK_FILE_AND_ARG1_NAME='task-file-and-arg1-name-matches'
readonly _EXECUTION_TASK_MATCH_ARG1_NAME='arg1-name-matches'

function project:execution_task.parse_from_arguments() {
    local -n execution_task_struct_ref="${1}"
    shift

    mycmd.trace "Attempting to parse task from arguments: '${*}'."

    if (($# == 0)); then
        mycmd.debug "No arguments received."
        return 1
    fi

    if (($# > 1)); then
        if project:execution_task._get_if_valid "${!execution_task_struct_ref}" "${1}/${2}" 2; then
            mycmd.trace "'${1}/${2}' is a valid task, returning."
            return 0
        fi
    fi

    local task_file_and_arg1_matches=0
    local arg1_matches=0

    if [[ -v MYPROJECT_CURRENT_TASK_FILE && "${MYPROJECT_CURRENT_TASK_FILE}" != "main" ]]; then
        if project:execution_task._get_if_valid "${!execution_task_struct_ref}" "${MYPROJECT_CURRENT_TASK_FILE}/${1}" 1; then
            task_file_and_arg1_matches=1
        fi
    fi

    if project:execution_task._get_if_valid "${!execution_task_struct_ref}" "${1}" 1; then
        arg1_matches=1
    fi

    if ((task_file_and_arg1_matches == 0 && arg1_matches == 0)); then
        mycmd.error_output "Task not found for arguments '${*}'"
        return 1
    elif ((task_file_and_arg1_matches == 1 && arg1_matches == 1)); then
        mycmd.error_output "Ambiguous match for task with arguments '${*}', which could refer to either:"
        mycmd.error_output "- '${MYPROJECT_CURRENT_TASK_FILE} ${1}'; to use this one explicitly reference it with '${MYPROJECT_CURRENT_TASK_FILE} ${1}'."
        mycmd.error_output "- '${1}'; to use this one explicitly reference it with 'main ${1}'."

        execution_task_struct_ref=()
        return 1
    elif ((task_file_and_arg1_matches == 1)); then
        mycmd.trace "Found match for task '${MYPROJECT_CURRENT_TASK_FILE} ${1}'."
    else
        mycmd.trace "Found match for task '${1}'."
    fi

    return 0
}

function project:execution_task._get_if_valid() {
    local -n execution_task_struct="${1}"
    local -r fully_qualified_task_name="${2}"
    local -r shift_amount="${3}"

    if project:task_registry.task_exists_with_fully_qualified_task_name "${fully_qualified_task_name}"; then
        mycmd.trace "Returning execution task information:"
        execution_task_struct["${_EXECUTION_TASK_FULLY_QUALIFIED_NAME_FIELD}"]="${fully_qualified_task_name}"
        mycmd.trace "- ${_EXECUTION_TASK_FULLY_QUALIFIED_NAME_FIELD}: ${execution_task_struct["${_EXECUTION_TASK_FULLY_QUALIFIED_NAME_FIELD}"]}"
        execution_task_struct["${_EXECUTION_TASK_ARGUMENT_SHIFT_AMOUNT_FIELD}"]="${shift_amount}"
        mycmd.trace "- ${_EXECUTION_TASK_ARGUMENT_SHIFT_AMOUNT_FIELD}: ${execution_task_struct["${_EXECUTION_TASK_ARGUMENT_SHIFT_AMOUNT_FIELD}"]}"

        return 0
    else
        return 1
    fi
}

function project:execution_task.get_fully_qualified_task_name() {
    project:execution_task._get_field_from_struct \
        "${_EXECUTION_TASK_FULLY_QUALIFIED_NAME_FIELD}" \
        "${@}"
}

function project:execution_task.get_shift_amount() {
    project:execution_task._get_field_from_struct \
        "${_EXECUTION_TASK_ARGUMENT_SHIFT_AMOUNT_FIELD}" \
        "${@}"
}

function project:execution_task._get_field_from_struct() {
    local -r field_name="${1}"
    # shellcheck disable=SC2178
    local -n execution_struct_ref="${2}"

    if [[ -v execution_struct_ref["${field_name}"] ]]; then
        echo "${execution_struct_ref["${field_name}"]}"
        return 0
    else
        mycmd.debug "Missing required execution field '${field_name}'."
        return 1
    fi
}

function project._extract_task_positions() {
    local -n task_positions_ref="${1}"
    shift

    if (($# == 0)); then
        mycmd.debug "No arguments passed."
        return 1
    fi

    local -i arg_index=1
    task_positions_ref+=(0)
    shift

    while (($# > 0)); do
        ((arg_index += 1))

        if [[ "${1}" = ";" && $# -gt 0 ]]; then
            task_positions_ref+=("${arg_index}")
        fi

        shift
    done
}

mycmd.trace "The MyProject Execution command group support library has been sourced."
