# -*- mode: shell-script; sh-shell: bash; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=bash

# MyProject User Command Group Support Library
#   All of the User-facing Functions for MyProject

set -o nounset -o errexit -o errtrace -o pipefail

(return 0 >/dev/null 2>&1) || {
    # coverage skip: 2
    echo >&2 "$0 is a library only meant to be sourced."
    exit 1
}

[[ -n "${_MYPROJECT_USER_LIB:-}" ]] && return
readonly _MYPROJECT_USER_LIB=1

mycmd:command_group.load_support_lib "execution"
mycmd:command_group.load_support_lib "fileset"
mycmd:command_group.load_support_lib "output"
mycmd:command_group.load_support_lib "task"

function myproject.register_task() {
    local -r task_name="${1}"
    shift

    local task_function_name
    if (($# == 0)); then
        task_function_name="${task_name}"
    else
        task_function_name="${1}"
        shift
    fi
    readonly task_function_name

    local fully_qualified_task_name
    if ! fully_qualified_task_name="$(myproject._get_fully_qualified_task_name "${task_name}")"; then
        # coverage skip: 1
        return 1
    fi
    readonly fully_qualified_task_name

    project:task_registry.new_task \
        "${MYPROJECT_CURRENT_TASK_FILE}" \
        "${fully_qualified_task_name}" \
        "${task_function_name}" \
        "${@}"
}

function myproject.register_task_with_fileset() {
    local -r task_name="${1}"
    local -r task_function_name="${2}"
    local -r fileset_name="${3}"
    shift 3

    local fully_qualified_task_name
    if ! fully_qualified_task_name="$(myproject._get_fully_qualified_task_name "${task_name}")"; then
        # coverage skip: 1
        return 1
    fi
    readonly fully_qualified_task_name

    project:task_registry.new_task_with_fileset \
        "${MYPROJECT_CURRENT_TASK_FILE}" \
        "${fully_qualified_task_name}" \
        "${task_function_name}" \
        "${fileset_name}" \
        "${@}"
}

function myproject._get_fully_qualified_task_name() {
    local -r task_name="${1}"

    if ! [[ -v MYPROJECT_CURRENT_TASK_FILE ]]; then
        # coverage skip: 2
        mycmd.debug "Required variable MYPROJECT_CURRENT_TASK_FILE is not set"
        return 1
    fi

    local -r fully_qualified_task_name="${MYPROJECT_CURRENT_TASK_FILE}/${task_name}"

    echo "${fully_qualified_task_name}"
}

shopt -s expand_aliases
alias myproject.register_fileset='project:fileset_registry.new_fileset'
alias myproject.add_files_to_fileset='project:fileset.add_files'
alias myproject.find_and_add_files_to_fileset='project:fileset.find_and_add_files'

function myproject.list_files() {
    local -n fileset="${1}"

    myproject.for_each_in_fileset "${!fileset}" mycmd.output
}

function myproject.for_each_in_fileset() {
    local -n fileset="${1}"
    local -r action="${2}"

    local f
    for f in "${fileset[@]}"; do
        "${action}" "${f}"
    done
}

alias myproject.execute_task='project.execute_task'
alias myproject.execute_tasks='project.execute_tasks'

alias myproject.enable_quiet_mode='project.enable_quiet_mode'
alias myproject.disable_quiet_mode='project.disable_quiet_mode'
alias myproject.is_quiet_enabled='project.is_quiet_enabled'
alias myproject.output_only_if_not_quiet='project.output_only_if_not_quiet'

alias myproject.enable_verbose_mode='project.enable_verbose_mode'
alias myproject.disable_verbose_mode='project.disable_verbose_mode'
alias myproject.is_verbose_enabled='project.is_verbose_enabled'
alias myproject.verbose_output='project.verbose_output'

mycmd.trace "The MyProject User command group support library has been sourced."
